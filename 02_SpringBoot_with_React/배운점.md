# 🧠 배운점

### 01_스프링 부트 프로젝트의 스프링 빈 등록 과정

스프링의 중요 기능 중 하나 => 의존성 주입 컨테이너로서의 기능

스프링은 베이스 패키지와 그 하위 패키지에서 자바 빈을 찾아 스프링의 의존성 주입 컨테이너 오브젝트에 등록한다.

1. 스프링 부트 어플리케이션이 시작한다.(@SpringBootApplication)
2. @ComponentScan 애너테이션이 있는 경우 베이스 패키지와 그 하위 패키지에서 @Component가 달린 클래스를 찾는다.
   1. 기본적으로 @SpringBootApplication은 @ComponentScan을 포함하고 있다
3. 필요한 경우 @Component가 달린 클래스의 오브젝트를 생성한다. 이때 생성하려는 오브젝트가 다른 오브젝트에 의존한다면, 즉 멤버 변수로 다른 클래스를 갖고 있다면 그 멤버 변수 오브젝트를 찾아 넣어줘야 한다.
   1. @Autowired를 사용하는 경우 @Autowired에 연결된 변수의 클래스가 @Component가 달린 클래스인 경우 스프링이 오브젝트를 자동으로 생성해준다.
   2. 만약 @Bean 애너테이션으로 생성하는 오브젝트인 경우 @Bean이 달린 메서드를 불러 생성해 넘겨준다.

<br>

### 02_레이어드 아키텍쳐

스프링 부트 프로젝트는 레이어드 아키텍쳐로 구성되어 있다. 레이어드 아키텍쳐(Layer Architecture)는 어플리케이션을 구성하는 요소들이 계층적으로 나누어져있다는 의미이다.

#### 레이어드 아키텍쳐로 구성되지 않는다면?

하나의 클래스 내에 모든 것을 작성하므로 코드가 길어지면서 매우 복잡해진다. 라이브러리나 사용하는 함수 등 복잡한 비즈니스 로직을 가졌다면 import하는 구문만 몇백줄이 될 수도 있다.

#### 레이어드 아키텍쳐

결국 레이어드 아키텍쳐란 비슷한 일을 하는 계층끼리 클래스나 인터페이스를 분리시켰다는 의미이다.
=> 컨트롤러는 서비스에 요청하고, 서비스는 퍼시스턴스에 요청하고, 퍼시스턴스는 DB에 요청하여 데이터를 받는다. 해당 데이터를 서비스에 반환하고, 서비스는 데이터를 검토 및 가공하여 컨트롤러에게 반환한다. 컨트롤러도 서비스로부터 받은 데이터를 검토 및 가공하여 요청에 따른 결과를 반환하는 것이다.

<br>

### 03_비즈니스 어플리케이션 클래스

보통 자바로 구현한 비즈니스 어플리케이션 클래스는 두 가지 종류로 나눌 수 있다.

- **기능을 수행하는 클래스**; 실질적으로 우리가 구현하고자 하는 비즈니스 로직에 맞게 동작을 하는 클래스
  - 컨트롤러, 서비스, 퍼시스턴스
- **데이터를 담는 클래스**; 실질적인 기능 없이 DB로 부터 반환받은 비즈니스 데이터를 전달, 보관하기 위한 용도의 클래스
  - Entity, Model, DTO

<br>

### 04_DTO를 사용하는 이유?

왜 서비스는 요청을 처리한 뒤에 모델(Model)을 반환하지 않고 DTO를 통해서 데이터를 반환할까?

- 비즈니스 로직을 캡슐화하기 위함
  - 모델은 데이터 베이스 테이블 구조와 매우 유사함. 모델이 갖고 있는 필드는 DB테이블의 스키마와 비슷할 확률이 높은데, 외부인이 쉽게 비즈니스 데이터 구조, 서비스 내부 로직에 대해 쉽게 알 수 없게끔 방지할 수 있다
- 요청에 따른 필요 정보를 모델이 전부 포함하고 있지 않을 수도 있기 때문
  - 예) 에러 메세지가 발생했을 경우, 에러 메세지에 대한 데이터를 어디에 포함시키는 것이 좋을까? 모델에 필드를 하나 할당하는 것이 좋을까? 만약 에러 메세지 외에 다른 추가 내용이 필요하다면? 그것들도 전부 모델에 필드를 생성해야할까?
  - 그렇지 않다. 어떤 데이터 내용은 서비스 로직과 무관한 경우도 있고, 매번 이런 식으로 어떤 상황이 발생했을 때마다 모델을 변경해주는 것은 별로 좋지 못하다. 따라서 순수하게 데이터만 담아서 반환하기 위한 목적으로 DTO클래스를 만들고 사용한다

<br>

###  05_@RestController

@RestController는 크게 @Controller와 @ResponseBody로 이루어져있다

스프링이 오브젝트를 JSON으로 바꿔주는데, 오브젝트를 저장하거나 네트워크를 통해 저장할 수 있도록 JSON형태로 변환하는 것을 직렬화(Serialization)이라고 하고, JSON을 오브젝트로 변환하는 것을 역직렬화(Deserialization)이라고 한다.

<br>

### 06_@Table(name="xxx")

![image](https://user-images.githubusercontent.com/93081720/178307666-e7cdb289-62b2-44e0-abbb-86d4cf56f12d.png)

name으로 지정한 데이터 테이블과 해당 엔티티 클래스를 맵핑시켜주는 애너테이션

만약 사용하지 않을 경우 @Entity 애너테이션이 적용된 클래스 명을 데이터 테이블로 간주한다

따라서 이 경우 @Table을 쓰지 않고 Entity 클래스 명을 Todo로 지어도 된다.

<br>

### 07_JpaRepository<T, ID>

T(타입)에는 해당 레포지토리와 맵핑될 Entity를 쓰고

ID에는 해당 Entity의 기본 키의 타입을 쓴다

<br>

